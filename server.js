/*
 * Production-ready Express server for the DigitalBank MVP.
 *
 * This server exposes two HTTP endpoints:
 *  1. POST /api/savings – records a new savings event from a device.
 *  2. GET  /api/latest-savings – returns the latest event ID for a device.
 *
 * Compared to the prototype, this implementation introduces several
 * improvements designed for a production environment:
 *
 *  - Persistent storage: Events and device metadata are stored in
 *    Google Cloud Firestore instead of in-memory objects. This
 *    ensures data is not lost across restarts and enables multiple
 *    server instances to operate in parallel.
 *  - Atomicity: Updates to a device's total amount and latest event
 *    identifier are performed inside a Firestore transaction to
 *    prevent race conditions when multiple requests arrive
 *    concurrently.
 *  - Validation and error handling: Requests are validated and
 *    structured error responses are returned. Unexpected errors are
 *    logged and a 500 status code is returned without leaking
 *    sensitive information.
 *  - Configuration via environment variables: Port and Firebase
 *    credentials are loaded from the environment so that sensitive
 *    configuration is not hard-coded into the source file. See the
 *    accompanying README or deployment documentation for details.
 *  - Middleware: Helmet and Morgan are used to set sensible HTTP
 *    headers and log requests respectively. JSON parsing is also
 *    enabled globally.
 *
 * Before running this server you must set up a Firebase project and
 * generate a service account JSON key file. Provide the path to this
 * key in the `GOOGLE_APPLICATION_CREDENTIALS` environment variable.
 *
 * Author: Generated by ChatGPT on behalf of the DigitalBank project.
 */

const express = require('express');
const helmet = require('helmet');
const morgan = require('morgan');
const admin = require('firebase-admin');

// Load environment variables. In production, set these via your
// hosting provider or a .env file (using the `dotenv` package).
const PORT = process.env.PORT || 3000;

// Initialise the Firebase Admin SDK. When running on a GCP
// environment (e.g. Cloud Run), credentials can be provided by
// default service accounts. Locally or in other environments, set
// GOOGLE_APPLICATION_CREDENTIALS to the path of the service account
// JSON file.
try {
  admin.initializeApp();
} catch (err) {
  // If initialization fails, log the error and exit gracefully. The
  // most common cause is missing credentials.
  console.error('Failed to initialise Firebase Admin SDK:', err);
  process.exit(1);
}

const db = admin.firestore();
const devicesRef = db.collection('devices');

const app = express();

// Apply security and logging middleware.
app.use(helmet());
app.use(morgan('combined'));
app.use(express.json());

// Serve static files from the `public` directory so that the web frontend
// (e.g. web.html) can be hosted by the same server. This helps avoid
// CORS issues because the frontend and API share the same origin. Place
// your web assets (HTML, CSS, JS) under a folder named `public` next
// to this server.js file.
app.use(express.static('public'));

// CORS / preflight support: allow requests from any origin during local
// development. In production, restrict the allowed origin to your
// deployed frontend domain. This middleware also handles OPTIONS
// requests by returning a 204 status, which prevents 404 errors when
// browsers send a preflight request before POST/DELETE calls.
app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET,POST,OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
  if (req.method === 'OPTIONS') {
    // End preflight requests quickly with no body.
    return res.sendStatus(204);
  }
  next();
});

/**
 * POST /api/savings
 *
 * Body parameters:
 *  - amount (number): The amount saved in the current event.
 *  - deviceId (string): Unique identifier of the device submitting
 *    the event.
 *
 * Responds with JSON containing:
 *  - ok (boolean): whether the operation succeeded.
 *  - latestEventId (number): the new latest event identifier for
 *    this device.
 *  - total (number): the aggregated total amount saved for this
 *    device.
 *
 * The endpoint validates inputs and returns HTTP 400 for bad requests.
 * It uses a Firestore transaction to atomically update the device
 * document and create a new event document in a sub-collection.
 */
app.post('/api/savings', async (req, res) => {
  const { amount, deviceId } = req.body;
  // Validate input – amount must be a positive number and deviceId must be
  // non-empty.
  if (typeof amount !== 'number' || isNaN(amount) || amount <= 0) {
    return res.status(400).json({ error: 'amount must be a positive number' });
  }
  if (!deviceId || typeof deviceId !== 'string' || !deviceId.trim()) {
    return res.status(400).json({ error: 'deviceId is required and must be a string' });
  }

  let newEventId;
  let newTotal;
  try {
    await db.runTransaction(async transaction => {
      const deviceDocRef = devicesRef.doc(deviceId);
      const deviceDoc = await transaction.get(deviceDocRef);
      const data = deviceDoc.exists ? deviceDoc.data() : {};
      const currentTotal = typeof data.total === 'number' ? data.total : 0;
      const currentEventId = typeof data.latestEventId === 'number' ? data.latestEventId : 0;
      newEventId = currentEventId + 1;
      newTotal = currentTotal + amount;
      // Update aggregate fields on the device document.
      transaction.set(deviceDocRef, { total: newTotal, latestEventId: newEventId }, { merge: true });
      // Create a new event in a sub-collection for audit/history purposes.
      const eventsRef = deviceDocRef.collection('events');
      const eventDocRef = eventsRef.doc(String(newEventId));
      transaction.set(eventDocRef, {
        eventId: newEventId,
        amount: amount,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });
    });
    return res.status(201).json({ ok: true, latestEventId: newEventId, total: newTotal });
  } catch (err) {
    // Log the error and return a generic error message.
    console.error('Error while processing /api/savings:', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

/**
 * GET /api/latest-savings
 *
 * Query parameters:
 *  - deviceId (string): Unique identifier of the device.
 *
 * Responds with the latest event ID for the specified device as a
 * plain string. This format keeps the ESP32 firmware simple – it
 * only needs to parse an integer from the response body.
 */
app.get('/api/latest-savings', async (req, res) => {
  const deviceId = req.query.deviceId;
  if (!deviceId || typeof deviceId !== 'string' || !deviceId.trim()) {
    return res.status(400).send('deviceId query parameter is required');
  }
  try {
    const deviceDoc = await devicesRef.doc(deviceId).get();
    const data = deviceDoc.exists ? deviceDoc.data() : {};
    const latestEventId = typeof data.latestEventId === 'number' ? data.latestEventId : 0;
    // Respond with plain text for ease of parsing on the microcontroller.
    res.type('text/plain').send(String(latestEventId));
  } catch (err) {
    console.error('Error while processing /api/latest-savings:', err);
    return res.status(500).send('Internal server error');
  }
});

// Catch-all for unrecognised routes.
app.use((req, res) => {
  res.status(404).json({ error: 'Not found' });
});

// Global error handler – ensures any uncaught errors are returned as
// HTTP 500 and logged. Express will skip this if the route already
// handled the error.
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// Start the server. Listen on the configured port and log a message
// to indicate readiness.
app.listen(PORT, () => {
  console.log(`Server started on port ${PORT}`);
});